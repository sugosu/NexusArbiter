{
  "implementation_story_rules": {
    "mode": "strict",

    "structure": [
      "System Overview & Goals",
      "Runtime Environment & Execution Model",
      "Actors & External Interfaces",
      "Core Concepts & Domain Objects",
      "State Model & Transitions",
      "Main Loop / Main Flow",
      "Modules & Responsibilities",
      "Classes & Methods",
      "Data Structures & Types",
      "Configuration Parameters",
      "Randomness & Determinism",
      "Error Handling & Failure Modes",
      "Logging & Observability",
      "Performance Considerations",
      "Extension Points",
      "Testing Strategy"
    ],

    "structure_rules": {
      "authoritative": true,
      "description": "When mode = strict, the story MUST follow exactly the section order and section names defined in 'structure'. No additional sections, no reordered sections, no merged sections."
    },

    "requirements": {
      "overview": {
        "must_define": [
          "Purpose of the system or game in clear terms.",
          "Primary goals and success criteria.",
          "Non-goals (explicitly define what is out of scope).",
          "Global assumptions (single process, deterministic behaviour, adapter-driven, or other)."
        ]
      },

      "environment": {
        "must_define": [
          "Runtime model (single-threaded loop, event-driven, request-response, hybrid).",
          "Execution model (tick-based loop, turn-based steps, input-driven flow).",
          "Entrypoint component (what starts and orchestrates the system).",
          "Persistence expectations (none, local save files, memory-only, or external service).",
          "Whether the system includes a UI/renderer or is headless."
        ]
      },

      "actors": {
        "must_define": [
          "Human or external actors that interact with the system.",
          "Adapters or external services (input, rendering, audio, persistence, networking).",
          "Direction and purpose of interaction between each actor and the system."
        ]
      },

      "core_concepts": {
        "must_define": [
          "All key domain objects (game objects or system entities).",
          "For each: identity, key attributes, conceptual types.",
          "Required invariants (constraints that must always hold).",
          "Distinguish domain data from technical support structures."
        ]
      },

      "state_model": {
        "must_define": [
          "A simple explicit state machine for the system (e.g., MENU, ACTIVE, PAUSED, ERROR, SHUTDOWN).",
          "Description of each state.",
          "Allowed transitions between states.",
          "Component responsible for storing and updating state."
        ]
      },

      "main_flow": {
        "must_define": [
          "System initialization order.",
          "Canonical single-cycle or tick sequence (input → update → output, or similar).",
          "Responsibilities and outputs of each step.",
          "Shutdown behaviour and cleanup rules."
        ]
      },

      "modules": {
        "must_define": [
          "List of modules with clearly separated responsibilities.",
          "For each module: what it will NOT do (non-responsibilities).",
          "Dependencies between modules (caller–callee relation)."
        ]
      },

      "classes_methods": {
        "must_define": [
          "For each module: key classes and their purpose.",
          "Fields/properties of each class with conceptual types.",
          "Public methods with purpose, parameters, return values.",
          "Method side effects and error behaviour."
        ]
      },

      "data_structures": {
        "must_define": [
          "All important data structures used across the system.",
          "Fields with conceptual types and clear meaning.",
          "Any enums, statuses, event types, or code sets."
        ]
      },

      "configuration": {
        "must_define": [
          "Central configuration object with tunable parameters.",
          "Meaning and expected range/value for each parameter.",
          "Which modules read each parameter.",
          "Distinguish tunable config from fixed domain constants."
        ]
      },

      "randomness": {
        "must_define": [
          "Whether randomness exists in the system.",
          "Exact policy (uniform, weighted, sequence-based, deterministic fallback).",
          "Seeding strategy and replay determinism.",
          "Component owning the RNG."
        ],
        "if_none": "Explicitly state that the system is fully deterministic."
      },

      "error_handling": {
        "must_define": [
          "Global error-handling philosophy (throw, log, recover).",
          "Typical module-level error conditions and their handling.",
          "Fatal vs recoverable errors."
        ]
      },

      "logging_observability": {
        "must_define": [
          "Which actions, transitions, or failures must be logged.",
          "Logging levels and their intended semantics.",
          "Optional metrics or counters if relevant."
        ]
      },

      "performance": {
        "must_define": [
          "Basic performance expectations (responsiveness, update timing).",
          "Any critical operations or constraints.",
          "Explicit statement if performance is not a major concern."
        ]
      },

      "extension_points": {
        "must_define": [
          "Where the system can be extended (plugins, adapters, strategy objects).",
          "Contracts/interfaces extensions must satisfy.",
          "How extensions are registered or configured."
        ]
      },

      "testing": {
        "must_define": [
          "Testing approach (unit, integration, end-to-end).",
          "Key components suitable for isolated tests.",
          "Critical scenarios and edge cases.",
          "Test doubles implied by design (fake adapter, fake RNG, etc.)."
        ]
      }
    },

    "meta_rules": {
      "style": [
        "Plain text only in params.code; the JSON envelope is exempt from this rule.",
        "Descriptions must allow direct implementation without guessing.",
        "Avoid vague expressions like 'etc' without specific detail.",
        "All behaviour must be deterministic unless stated otherwise.",
        "Every module/class/structure mentioned must be defined clearly."
      ]
    }
  }
}
