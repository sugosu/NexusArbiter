{"mode":"strict","metadata":{"system_name":"project_task_manager","source_type":"derived_from_story","language":"python","version":"1.0.0"},"classes":[{"id":"external.User","file_path":null,"class_name":null,"role":"external_actor","purpose":"Represents a human invoking the program once via CLI; provides a single JSON string argument as the operation input.","depends_on":[],"interactions":[],"notes":["External boundary for the single-run CLI invocation via argv; not generated as code."]},{"id":"main.Main","file_path":"main.py","class_name":"Main","role":"entry_point","purpose":"Application entry point. Wires dependencies, receives the single JSON command from the external caller, and invokes the application layer to perform exactly one operation.","depends_on":["app.Application","app_logging.AppLogger"],"interactions":[{"target_id":"external.User","interaction_method":"invoke(json_command)","interaction_way":"external input","semantics":"Receives one JSON command string as a single CLI argument; entry boundary for the run."},{"target_id":"app.Application","interaction_method":"run(command_json, data_dir)","interaction_way":"method call","semantics":"Delegates the single operation to the application orchestration layer; passes data directory/path explicitly as a method-level parameter."},{"target_id":"app_logging.AppLogger","interaction_method":"info/error","interaction_way":"method call","semantics":"Logs startup and fatal errors; no business logic in the entry point."}],"notes":["Must not contain business logic beyond wiring and a single invocation.","Parses argv externally provided JSON string and forwards it unchanged to the app layer."]},{"id":"app.Application","file_path":"app/application.py","class_name":"Application","role":"app","purpose":"Top-level orchestration component. Receives the parsed command and dispatches it to the controller/dispatcher; owns no persistence details.","depends_on":["controller.Dispatcher","app_logging.AppLogger"],"interactions":[{"target_id":"controller.Dispatcher","interaction_method":"dispatch(command)","interaction_way":"method call","semantics":"Single dispatch entry into the controller layer to execute the requested operation."},{"target_id":"app_logging.AppLogger","interaction_method":"info/debug","interaction_way":"method call","semantics":"Logs high-level orchestration events and results."}],"notes":["Does not call repositories or storage adapters directly; it delegates to controller."]},{"id":"controller.Dispatcher","file_path":"controller/dispatcher.py","class_name":"Dispatcher","role":"controller","purpose":"Interprets the incoming command and delegates to the appropriate domain services for projects and tasks.","depends_on":["service.ProjectService","service.TaskService","app_logging.AppLogger"],"interactions":[{"target_id":"service.ProjectService","interaction_method":"handle_project_command(command)","interaction_way":"method call","semantics":"Delegates project-related operations (create/list/get/update/delete) to the ProjectService."},{"target_id":"service.TaskService","interaction_method":"handle_task_command(command)","interaction_way":"method call","semantics":"Delegates task-related operations (create/list/get/update/delete) to the TaskService."},{"target_id":"app_logging.AppLogger","interaction_method":"debug/info","interaction_way":"method call","semantics":"Logs dispatch decisions and incoming command summaries."}],"notes":[]},{"id":"service.ProjectService","file_path":"service/project_service.py","class_name":"ProjectService","role":"domain_service","purpose":"Encapsulates project domain logic: validate project data, enforce id uniqueness, and prevent deleting a project that still has tasks.","depends_on":["repository.ProjectRepository","repository.TaskRepository","app_logging.AppLogger"],"interactions":[{"target_id":"repository.ProjectRepository","interaction_method":"load_all(data_dir)/save_all(data_dir, projects)","interaction_way":"method call","semantics":"Loads and persists project records; data_dir is passed explicitly as a method-level parameter to preserve parameter ownership."},{"target_id":"repository.TaskRepository","interaction_method":"load_all(data_dir)","interaction_way":"method call","semantics":"Reads tasks to validate referential integrity and to check for existing tasks when deleting a project."},{"target_id":"app_logging.AppLogger","interaction_method":"debug/info/error","interaction_way":"method call","semantics":"Logs domain events, validation failures, and conflict conditions."}],"notes":["Enforces referential integrity: project deletion checks task repository for related tasks and returns a conflict error if any exist.","IDs are expected to be provided by the caller and must be unique; uniqueness is validated by examining loaded records."]},{"id":"service.TaskService","file_path":"service/task_service.py","class_name":"TaskService","role":"domain_service","purpose":"Encapsulates task domain logic: validate status and priority, ensure referenced project exists, and enforce id uniqueness within tasks.","depends_on":["repository.TaskRepository","repository.ProjectRepository","app_logging.AppLogger"],"interactions":[{"target_id":"repository.TaskRepository","interaction_method":"load_all(data_dir)/save_all(data_dir, tasks)","interaction_way":"method call","semantics":"Loads and persists task records; data_dir path is passed explicitly at method call time."},{"target_id":"repository.ProjectRepository","interaction_method":"load_all(data_dir)","interaction_way":"method call","semantics":"Checks that a referenced project id exists before creating or updating a task."},{"target_id":"app_logging.AppLogger","interaction_method":"debug/info/error","interaction_way":"method call","semantics":"Logs validation events, referential integrity checks, and errors."}],"notes":["Valid status values: todo, in_progress, done. Valid priority values: low, medium, high.","All validation and conflict detection produce user-level errors; services do not perform I/O directly."]},{"id":"repository.ProjectRepository","file_path":"repository/project_repository.py","class_name":"ProjectRepository","role":"repository","purpose":"Provides a persistence abstraction for project entities, mapping between domain records and JSON storage.","depends_on":["storage.JsonStorage","app_logging.AppLogger"],"interactions":[{"target_id":"storage.JsonStorage","interaction_method":"read(path)/write(path, data)","interaction_way":"method call","semantics":"Performs low-level JSON read/write of the projects file; path is passed explicitly by the caller."},{"target_id":"app_logging.AppLogger","interaction_method":"debug/error","interaction_way":"method call","semantics":"Logs persistence operations and I/O failures at the repository level."}],"notes":["Repository is responsible for mapping between raw JSON arrays and project domain records.","Public repository methods accept 'data_dir' or a file path parameter explicitly."]},{"id":"repository.TaskRepository","file_path":"repository/task_repository.py","class_name":"TaskRepository","role":"repository","purpose":"Provides a persistence abstraction for task entities, mapping between domain records and JSON storage.","depends_on":["storage.JsonStorage","app_logging.AppLogger"],"interactions":[{"target_id":"storage.JsonStorage","interaction_method":"read(path)/write(path, data)","interaction_way":"method call","semantics":"Performs low-level JSON read/write of the tasks file; path is passed explicitly by the caller."},{"target_id":"app_logging.AppLogger","interaction_method":"debug/error","interaction_way":"method call","semantics":"Logs persistence operations and I/O failures at the repository level."}],"notes":["Responsible for mapping JSON arrays to task domain records.","Public repository methods accept 'data_dir' or file path parameters explicitly."]},{"id":"storage.JsonStorage","file_path":"storage/json_storage.py","class_name":"JsonStorage","role":"storage_adapter","purpose":"Low-level JSON file storage adapter responsible for atomic read/write of JSON files in the local data directory.","depends_on":["app_logging.AppLogger"],"interactions":[{"target_id":"app_logging.AppLogger","interaction_method":"debug/error","interaction_way":"method call","semantics":"Logs file paths, read/write attempts, and I/O errors at the storage level."}],"notes":["Performs only JSON I/O; does not interpret domain concepts.","Write operations are atomic (caller-level semantics must ensure atomicity or adapter implements atomic replace).","Path ownership is external: callers pass file paths or data_dir explicitly."]},{"id":"app_logging.AppLogger","file_path":"app_logging.py","class_name":"AppLogger","role":"logging_adapter","purpose":"Application-level logging wrapper exposing info/debug/error APIs used by all layers.","depends_on":[],"interactions":[],"notes":["Named to avoid stdlib name collisions; does not perform business logic."]}]}