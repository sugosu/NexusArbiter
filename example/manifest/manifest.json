{
  "metadata": {
    "system_name": "library_manager",
    "language": "python",
    "version": "1.0.0",
    "source": "relationship+attributes"
  },
  "classes": [
    {
      "id": "main.Main",
      "module": "main",
      "file_path": "main.py",
      "class_name": "Main",
      "role": "entry_point",
      "depends_on": [
        "application.Application",
        "adapters.console.ConsolePrinter"
      ],
      "imports": [
        { "module": "application", "names": ["Application"] },
        { "module": "adapters.console", "names": ["ConsolePrinter"] }
      ],
      "fields": [
        { "name": "_application", "type": "Application", "origin": "dependency" },
        { "name": "_console_printer", "type": "ConsolePrinter", "origin": "dependency" }
      ],
      "constructor": {
        "signature": "__init__(self, application: Application, console_printer: ConsolePrinter) -> None",
        "parameters": [
          { "name": "application", "type": "Application" },
          { "name": "console_printer", "type": "ConsolePrinter" }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign application to self._application",
          "Assign console_printer to self._console_printer"
        ]
      },
      "methods": [
        {
          "name": "start",
          "visibility": "public",
          "return_type": "None",
          "parameters": [
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Print a startup/info message via self._console_printer.print_info(...)",
            "Call self._application.run(storage_path)",
            "If the call raises an exception, catch it and call self._console_printer.print_error(...) to surface a fatal error",
            "Return None"
          ]
        }
      ],
      "notes": [
        "Wires domain services, repositories, storage adapter, and console printer before invoking the run sequence.",
        "Must not contain business logic; only orchestration."
      ]
    },
    {
      "id": "application.Application",
      "module": "application",
      "file_path": "application.py",
      "class_name": "Application",
      "role": "orchestration",
      "depends_on": [
        "services.LibraryService",
        "adapters.console.ConsolePrinter"
      ],
      "imports": [
        { "module": "services.library_service", "names": ["LibraryService"] },
        { "module": "adapters.console", "names": ["ConsolePrinter"] },
        { "module": "typing", "names": ["Dict", "Any"] }
      ],
      "fields": [
        { "name": "_library_service", "type": "LibraryService", "origin": "dependency" },
        { "name": "_console_printer", "type": "ConsolePrinter", "origin": "dependency" }
      ],
      "constructor": {
        "signature": "__init__(self, library_service: LibraryService, console_printer: ConsolePrinter) -> None",
        "parameters": [
          { "name": "library_service", "type": "LibraryService" },
          { "name": "console_printer", "type": "ConsolePrinter" }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign library_service to self._library_service",
          "Assign console_printer to self._console_printer"
        ]
      },
      "methods": [
        {
          "name": "run",
          "visibility": "public",
          "return_type": "None",
          "parameters": [
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Call self._library_service.run_operations(storage_path) to perform domain operations and collect a summary (assume a Dict[str, Any])",
            "Store returned summary in a local variable 'summary'",
            "Call self._console_printer.print_summary(summary)",
            "Return None"
          ]
        }
      ],
      "notes": [
        "Application drives a non-interactive sequence and owns the overall run invocation.",
        "Passes storage_path explicitly to lower layers as a method-level parameter."
      ]
    },
    {
      "id": "services.LibraryService",
      "module": "services.library_service",
      "file_path": "services/library_service.py",
      "class_name": "LibraryService",
      "role": "domain_service",
      "depends_on": [
        "repositories.BookRepository",
        "repositories.MemberRepository",
        "repositories.LoanRepository"
      ],
      "imports": [
        { "module": "repositories.book_repository", "names": ["BookRepository"] },
        { "module": "repositories.member_repository", "names": ["MemberRepository"] },
        { "module": "repositories.loan_repository", "names": ["LoanRepository"] },
        { "module": "typing", "names": ["List", "Dict", "Any", "Optional"] }
      ],
      "fields": [
        { "name": "_book_repository", "type": "BookRepository", "origin": "dependency" },
        { "name": "_member_repository", "type": "MemberRepository", "origin": "dependency" },
        { "name": "_loan_repository", "type": "LoanRepository", "origin": "dependency" }
      ],
      "constructor": {
        "signature": "__init__(self, book_repository: BookRepository, member_repository: MemberRepository, loan_repository: LoanRepository) -> None",
        "parameters": [
          { "name": "book_repository", "type": "BookRepository" },
          { "name": "member_repository", "type": "MemberRepository" },
          { "name": "loan_repository", "type": "LoanRepository" }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign dependencies to corresponding self._* fields"
        ]
      },
      "methods": [
        {
          "name": "run_operations",
          "visibility": "public",
          "return_type": "Dict[str, Any]",
          "parameters": [
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Perform a deterministic, non-interactive sequence of domain operations using the storage_path passed in; do not assume global path.",
            "As a conservative default, this method will perform no destructive operations and will return a summary dict describing actions attempted.",
            "(Implementation guidance) Potential steps callers may implement here: read collections via repositories and call self.create_loan(...) for any scripted loan creations. This blueprint leaves the exact operation list to the implementer but documents that storage_path must be forwarded to repository calls.",
            "Return an operation summary dictionary (e.g., {\"created_loans\": [], \"skipped\": []})"
          ]
        },
        {
          "name": "create_loan",
          "visibility": "public",
          "return_type": "Dict[str, Any]",
          "parameters": [
            { "name": "book_id", "type": "str" },
            { "name": "member_id", "type": "str" },
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Call self._book_repository.find(book_id, storage_path) to obtain book data as a dict; if None, return {'success': False, 'reason': 'book_not_found'}",
            "Verify book.get('copies_available', 0) > 0; if not, return {'success': False, 'reason': 'no_available_copies'}",
            "Call self._member_repository.find(member_id, storage_path) to obtain member data as a dict; if None, return {'success': False, 'reason': 'member_not_found'}",
            "Call self._loan_repository.list_active_by_member(member_id, storage_path) to get active loans list and compute active_count = len(list)",
            "If active_count >= member.get('loan_limit', 0), return {'success': False, 'reason': 'member_limit_reached'}",
            "Construct a new loan dict with minimal fields: loan_id (deterministic placeholder or generated by caller), 'book_id', 'member_id', 'loan_date' (caller to supply or set to a conservative placeholder), 'due_date' (placeholder), 'returned': False",
            "Decrement book['copies_available'] by 1 and call self._book_repository.update(book, storage_path)",
            "Increment member['current_loans'] by 1 if present and call self._member_repository.update(member, storage_path)",
            "Call self._loan_repository.create(loan_dict, storage_path)",
            "Return {'success': True, 'loan': loan_dict}"
          ]
        }
      ],
      "notes": [
        "Service methods receive storage_path as a method-level parameter and do not assume global path ownership.",
        "Enforces invariants: available copies > 0 and member active loans < member.loan_limit before creating a loan."
      ]
    },
    {
      "id": "repositories.BookRepository",
      "module": "repositories.book_repository",
      "file_path": "repositories/book_repository.py",
      "class_name": "BookRepository",
      "role": "repository",
      "depends_on": [
        "storage.JsonStorage"
      ],
      "imports": [
        { "module": "storage.json_storage", "names": ["JsonStorage"] },
        { "module": "typing", "names": ["Optional", "Dict", "Any", "List"] }
      ],
      "fields": [
        { "name": "_storage", "type": "JsonStorage", "origin": "dependency" }
      ],
      "constructor": {
        "signature": "__init__(self, storage: JsonStorage) -> None",
        "parameters": [
          { "name": "storage", "type": "JsonStorage" }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign storage to self._storage"
        ]
      },
      "methods": [
        {
          "name": "find",
          "visibility": "public",
          "return_type": "Optional[Dict[str, Any]]",
          "parameters": [
            { "name": "book_id", "type": "str" },
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Call self._storage.read(storage_path) to obtain raw data (expected to be a dict or list containing book records)",
            "Locate the book record where record.get('id') == book_id; if found return that dict; otherwise return None"
          ]
        },
        {
          "name": "update",
          "visibility": "public",
          "return_type": "None",
          "parameters": [
            { "name": "book", "type": "Dict[str, Any]" },
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Call self._storage.read(storage_path) to obtain current collection (assume a list under a known key or top-level list)",
            "Replace the existing book record with matching 'id' with the provided book dict; if not present, append it",
            "Call self._storage.write(storage_path, updated_data) to persist the updated collection"
          ]
        }
      ],
      "notes": [
        "Public methods accept storage_path (or file path) as method parameters; repository does not own global path state."
      ]
    },
    {
      "id": "repositories.MemberRepository",
      "module": "repositories.member_repository",
      "file_path": "repositories/member_repository.py",
      "class_name": "MemberRepository",
      "role": "repository",
      "depends_on": [
        "storage.JsonStorage"
      ],
      "imports": [
        { "module": "storage.json_storage", "names": ["JsonStorage"] },
        { "module": "typing", "names": ["Optional", "Dict", "Any", "List"] }
      ],
      "fields": [
        { "name": "_storage", "type": "JsonStorage", "origin": "dependency" }
      ],
      "constructor": {
        "signature": "__init__(self, storage: JsonStorage) -> None",
        "parameters": [
          { "name": "storage", "type": "JsonStorage" }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign storage to self._storage"
        ]
      },
      "methods": [
        {
          "name": "find",
          "visibility": "public",
          "return_type": "Optional[Dict[str, Any]]",
          "parameters": [
            { "name": "member_id", "type": "str" },
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Call self._storage.read(storage_path) to obtain raw member collection",
            "Locate member record where record.get('id') == member_id; return the dict if found, else return None"
          ]
        },
        {
          "name": "update",
          "visibility": "public",
          "return_type": "None",
          "parameters": [
            { "name": "member", "type": "Dict[str, Any]" },
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Call self._storage.read(storage_path) to obtain current members collection",
            "Replace or append the member record matching 'id' with provided member dict",
            "Call self._storage.write(storage_path, updated_data) to persist"
          ]
        }
      ],
      "notes": [
        "Public methods accept storage_path as method parameters; no global path ownership."
      ]
    },
    {
      "id": "repositories.LoanRepository",
      "module": "repositories.loan_repository",
      "file_path": "repositories/loan_repository.py",
      "class_name": "LoanRepository",
      "role": "repository",
      "depends_on": [
        "storage.JsonStorage"
      ],
      "imports": [
        { "module": "storage.json_storage", "names": ["JsonStorage"] },
        { "module": "typing", "names": ["List", "Dict", "Any"] }
      ],
      "fields": [
        { "name": "_storage", "type": "JsonStorage", "origin": "dependency" }
      ],
      "constructor": {
        "signature": "__init__(self, storage: JsonStorage) -> None",
        "parameters": [
          { "name": "storage", "type": "JsonStorage" }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign storage to self._storage"
        ]
      },
      "methods": [
        {
          "name": "list_active_by_member",
          "visibility": "public",
          "return_type": "List[Dict[str, Any]]",
          "parameters": [
            { "name": "member_id", "type": "str" },
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Call self._storage.read(storage_path) to obtain current loans collection",
            "Filter loan records where record.get('member_id') == member_id and record.get('returned') is False; return the filtered list"
          ]
        },
        {
          "name": "create",
          "visibility": "public",
          "return_type": "Dict[str, Any]",
          "parameters": [
            { "name": "loan", "type": "Dict[str, Any]" },
            { "name": "storage_path", "type": "str" }
          ],
          "steps": [
            "Call self._storage.read(storage_path) to obtain loans collection",
            "Append the provided loan dict to the collection",
            "Call self._storage.write(storage_path, updated_collection)",
            "Return the appended loan dict"
          ]
        }
      ],
      "notes": [
        "Repository is responsible for mapping between raw JSON and Loan domain objects."
      ]
    },
    {
      "id": "storage.JsonStorage",
      "module": "storage.json_storage",
      "file_path": "storage/json_storage.py",
      "class_name": "JsonStorage",
      "role": "storage_adapter",
      "depends_on": [],
      "imports": [
        { "module": "json", "names": [] },
        { "module": "typing", "names": ["Any"] }
      ],
      "fields": [],
      "constructor": {
        "signature": "__init__(self) -> None",
        "parameters": [],
        "origin": "attributed",
        "body_plan": [
          "Trivial initializer; no I/O or path ownership performed here"
        ]
      },
      "methods": [
        {
          "name": "read",
          "visibility": "public",
          "return_type": "Any",
          "parameters": [
            { "name": "path", "type": "str" }
          ],
          "steps": [
            "Open file at 'path' for reading",
            "Call json.load on the opened file to deserialize JSON content",
            "Return the deserialized Python structure (dict/list/primitive)"
          ]
        },
        {
          "name": "write",
          "visibility": "public",
          "return_type": "None",
          "parameters": [
            { "name": "path", "type": "str" },
            { "name": "data", "type": "Any" }
          ],
          "steps": [
            "Open file at 'path' for writing",
            "Call json.dump(data, file, indent=2) to persist JSON-serializable data",
            "Ensure file is closed or use context manager to safely write"
          ]
        }
      ],
      "notes": [
        "Deals only with generic JSON-serializable structures and file paths provided by callers.",
        "No domain logic; callers own path and higher-level semantics."
      ]
    },
    {
      "id": "adapters.console.ConsolePrinter",
      "module": "adapters.console",
      "file_path": "adapters/console.py",
      "class_name": "ConsolePrinter",
      "role": "logging_adapter",
      "depends_on": [],
      "imports": [
        { "module": "typing", "names": ["Dict", "Any"] },
        { "module": "logging", "names": [] }
      ],
      "fields": [
        { "name": "_logger", "type": "logging.Logger", "origin": "state" }
      ],
      "constructor": {
        "signature": "__init__(self) -> None",
        "parameters": [],
        "origin": "attributed",
        "body_plan": [
          "Optionally create a stdlib logger for internal use (non-required); keep constructor trivial"
        ]
      },
      "methods": [
        {
          "name": "print_info",
          "visibility": "public",
          "return_type": "None",
          "parameters": [
            { "name": "message", "type": "str" }
          ],
          "steps": [
            "Output the message to stdout in a concise form (e.g., print(message))",
            "Optionally use stdlib logging.info if desired"
          ]
        },
        {
          "name": "print_error",
          "visibility": "public",
          "return_type": "None",
          "parameters": [
            { "name": "message", "type": "str" }
          ],
          "steps": [
            "Output the message to stderr or prefixed with 'ERROR:' via print(...)",
            "Optionally use stdlib logging.error if desired"
          ]
        },
        {
          "name": "print_summary",
          "visibility": "public",
          "return_type": "None",
          "parameters": [
            { "name": "summary", "type": "Dict[str, Any]" }
          ],
          "steps": [
            "Render a concise summary to stdout; do not print verbose domain dumps",
            "Prefer structured short lines (e.g., counts of created loans) rather than full records"
          ]
        }
      ],
      "notes": [
        "Used by entry point and application to present non-verbose output to the user."
      ]
    },
    {
      "id": "domain.book.Book",
      "module": "domain.book",
      "file_path": "domain/book.py",
      "class_name": "Book",
      "role": "domain_model",
      "depends_on": [],
      "imports": [
        { "module": "typing", "names": ["Dict", "Any"] }
      ],
      "fields": [
        { "name": "id", "type": "str", "origin": "state" },
        { "name": "title", "type": "str", "origin": "state" },
        { "name": "author", "type": "str", "origin": "state" },
        { "name": "copies_available", "type": "int", "origin": "state" }
      ],
      "constructor": {
        "signature": "__init__(self, id: str, title: str, author: str, copies_available: int) -> None",
        "parameters": [
          { "name": "id", "type": "str" },
          { "name": "title", "type": "str" },
          { "name": "author", "type": "str" },
          { "name": "copies_available", "type": "int" }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign parameters to corresponding instance attributes"
        ]
      },
      "methods": [
        {
          "name": "to_dict",
          "visibility": "public",
          "return_type": "Dict[str, Any]",
          "parameters": [],
          "steps": [
            "Return a dict with keys 'id','title','author','copies_available' mapping to instance fields"
          ]
        },
        {
          "name": "from_dict",
          "visibility": "public",
          "return_type": "Book",
          "parameters": [
            { "name": "data", "type": "Dict[str, Any]" }
          ],
          "steps": [
            "Create and return a Book instance from the provided dict by reading expected keys; do not perform I/O or business logic"
          ]
        }
      ],
      "notes": [
        "Domain model is passive and contains no behavior that is invoked by other components.",
        "Keep validation minimal; complex invariants belong in services."
      ]
    },
    {
      "id": "domain.member.Member",
      "module": "domain.member",
      "file_path": "domain/member.py",
      "class_name": "Member",
      "role": "domain_model",
      "depends_on": [],
      "imports": [
        { "module": "typing", "names": ["Dict", "Any"] }
      ],
      "fields": [
        { "name": "id", "type": "str", "origin": "state" },
        { "name": "name", "type": "str", "origin": "state" },
        { "name": "loan_limit", "type": "int", "origin": "state" },
        { "name": "current_loans", "type": "int", "origin": "state" }
      ],
      "constructor": {
        "signature": "__init__(self, id: str, name: str, loan_limit: int, current_loans: int = 0) -> None",
        "parameters": [
          { "name": "id", "type": "str" },
          { "name": "name", "type": "str" },
          { "name": "loan_limit", "type": "int" },
          { "name": "current_loans", "type": "int", "default": 0 }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign parameters to corresponding instance attributes"
        ]
      },
      "methods": [
        {
          "name": "to_dict",
          "visibility": "public",
          "return_type": "Dict[str, Any]",
          "parameters": [],
          "steps": [
            "Return a dict with member primitives (id,name,loan_limit,current_loans)"
          ]
        },
        {
          "name": "from_dict",
          "visibility": "public",
          "return_type": "Member",
          "parameters": [
            { "name": "data", "type": "Dict[str, Any]" }
          ],
          "steps": [
            "Instantiate and return a Member from data dict; do not perform I/O or call other components"
          ]
        }
      ],
      "notes": [
        "Domain model is passive and contains no behavior that is invoked by other components."
      ]
    },
    {
      "id": "domain.loan.Loan",
      "module": "domain.loan",
      "file_path": "domain/loan.py",
      "class_name": "Loan",
      "role": "domain_model",
      "depends_on": [],
      "imports": [
        { "module": "typing", "names": ["Dict", "Any", "Optional"] }
      ],
      "fields": [
        { "name": "loan_id", "type": "str", "origin": "state" },
        { "name": "book_id", "type": "str", "origin": "state" },
        { "name": "member_id", "type": "str", "origin": "state" },
        { "name": "loan_date", "type": "str", "origin": "state" },
        { "name": "due_date", "type": "str", "origin": "state" },
        { "name": "returned", "type": "bool", "origin": "state" }
      ],
      "constructor": {
        "signature": "__init__(self, loan_id: str, book_id: str, member_id: str, loan_date: str, due_date: str, returned: bool = False) -> None",
        "parameters": [
          { "name": "loan_id", "type": "str" },
          { "name": "book_id", "type": "str" },
          { "name": "member_id", "type": "str" },
          { "name": "loan_date", "type": "str" },
          { "name": "due_date", "type": "str" },
          { "name": "returned", "type": "bool", "default": false }
        ],
        "origin": "attributed",
        "body_plan": [
          "Assign parameters to corresponding instance attributes"
        ]
      },
      "methods": [
        {
          "name": "to_dict",
          "visibility": "public",
          "return_type": "Dict[str, Any]",
          "parameters": [],
          "steps": [
            "Return a dict with loan primitives (loan_id,book_id,member_id,loan_date,due_date,returned)"
          ]
        },
        {
          "name": "from_dict",
          "visibility": "public",
          "return_type": "Loan",
          "parameters": [
            { "name": "data", "type": "Dict[str, Any]" }
          ],
          "steps": [
            "Instantiate and return a Loan from data dict; do not perform I/O or call other components"
          ]
        }
      ],
      "notes": [
        "Domain model is passive and used only as data exchanged between services and repositories."
      ]
    }
  ],
  "initialization_graph": {
    "inferred": true,
    "composition_roots": ["main.Main"],
    "nodes": [
      {
        "id": "storage.JsonStorage",
        "module": "storage.json_storage",
        "class": "JsonStorage",
        "lifecycle": "singleton",
        "construct": { "type": "constructor", "params": [] }
      },
      {
        "id": "repositories.BookRepository",
        "module": "repositories.book_repository",
        "class": "BookRepository",
        "lifecycle": "singleton",
        "construct": {
          "type": "constructor",
          "params": [
            { "name": "storage", "source": "storage.JsonStorage", "source_type": "component" }
          ]
        }
      },
      {
        "id": "repositories.MemberRepository",
        "module": "repositories.member_repository",
        "class": "MemberRepository",
        "lifecycle": "singleton",
        "construct": {
          "type": "constructor",
          "params": [
            { "name": "storage", "source": "storage.JsonStorage", "source_type": "component" }
          ]
        }
      },
      {
        "id": "repositories.LoanRepository",
        "module": "repositories.loan_repository",
        "class": "LoanRepository",
        "lifecycle": "singleton",
        "construct": {
          "type": "constructor",
          "params": [
            { "name": "storage", "source": "storage.JsonStorage", "source_type": "component" }
          ]
        }
      },
      {
        "id": "services.LibraryService",
        "module": "services.library_service",
        "class": "LibraryService",
        "lifecycle": "singleton",
        "construct": {
          "type": "constructor",
          "params": [
            { "name": "book_repository", "source": "repositories.BookRepository", "source_type": "component" },
            { "name": "member_repository", "source": "repositories.MemberRepository", "source_type": "component" },
            { "name": "loan_repository", "source": "repositories.LoanRepository", "source_type": "component" }
          ]
        }
      },
      {
        "id": "adapters.console.ConsolePrinter",
        "module": "adapters.console",
        "class": "ConsolePrinter",
        "lifecycle": "singleton",
        "construct": { "type": "constructor", "params": [] }
      },
      {
        "id": "application.Application",
        "module": "application",
        "class": "Application",
        "lifecycle": "singleton",
        "construct": {
          "type": "constructor",
          "params": [
            { "name": "library_service", "source": "services.LibraryService", "source_type": "component" },
            { "name": "console_printer", "source": "adapters.console.ConsolePrinter", "source_type": "component" }
          ]
        }
      },
      {
        "id": "main.Main",
        "module": "main",
        "class": "Main",
        "lifecycle": "singleton",
        "construct": {
          "type": "constructor",
          "params": [
            { "name": "application", "source": "application.Application", "source_type": "component" },
            { "name": "console_printer", "source": "adapters.console.ConsolePrinter", "source_type": "component" }
          ]
        }
      }
    ],
    "notes": [
      "Initialization graph was derived by topologically sorting component constructor dependencies from relationship.json and attributes.json.",
      "This graph is marked 'inferred' because no explicit initialization_graph was provided in the upstream context."
    ]
  },
  "runtime": {
    "entrypoint": {
      "file": "main.py",
      "call": "Main.start",
      "description": "Call Main.start(storage_path) after wiring dependencies. The Main.start method orchestrates application.Application.run(storage_path) and reports via ConsolePrinter."
    }
  },
  "diagnostics": [
    {
      "level": "info",
      "message": "No contradictions detected between relationship.json and attributes.json. Initialization graph was synthesized (inferred=true) using declared depends_on edges. Composition root normalized to fully-qualified id 'main.Main'. Constructor parameter defaults for domain.member.Member.current_loans and domain.loan.Loan.returned were added to match declared signatures."
    }
  ]
}
