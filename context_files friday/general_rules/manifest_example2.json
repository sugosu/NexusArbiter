{
  "metadata": {
    "system_name": "ExampleServicePlatform",
    "domain": "Generic Distributed Application",
    "source_story_type": "implementation_story_v1",
    "version": "1.0.0"
  },
  "system_overview": {
    "purpose": "Provide a generic, modular service platform with clear separation between API layer, business logic, background processing, and persistence.",
    "primary_goals": [
      "Deterministic, well-defined behavior for core flows given a configuration.",
      "Loosely coupled modules that can be implemented and tested independently.",
      "A structure that downstream tools can use to generate code, tests, and wiring without guessing."
    ],
    "non_goals": [
      "Defining domain-specific business rules.",
      "Implementing a particular UI framework or frontend.",
      "Handling multi-tenant, multi-region deployment concerns."
    ]
  },
  "environment": {
    "runtime_model": "single_process_or_multi_process",
    "execution_model": "request_response_plus_background_jobs",
    "entrypoint": "HttpApiHost.start(ServerConfig) for synchronous calls; WorkerHost.start(WorkerConfig) for asynchronous jobs.",
    "persistence": {
      "strategy": "pluggable_data_store",
      "scope": "domain_entities_and_operational_metadata"
    },
    "ui_mode": "external_client_or_frontend",
    "headless_support": true
  },
  "actors": [
    {
      "name": "ClientApplication",
      "type": "external_system",
      "description": "Any external client (web, mobile, service) that invokes APIs or publishes messages.",
      "interaction_direction": "ClientApplication -> HttpApiHost -> ApplicationServices"
    },
    {
      "name": "Operator",
      "type": "human",
      "description": "Configures the platform, monitors logs and metrics, and triggers maintenance operations.",
      "interaction_direction": "Operator -> AdminInterface_or_CLI -> System"
    },
    {
      "name": "ExternalDataSource",
      "type": "external_system",
      "description": "Third-party or upstream system integrated via connectors or adapters.",
      "interaction_direction": "System <-> ExternalDataSource via connectors"
    }
  ],
  "state_model": {
    "states": [
      {
        "name": "STOPPED",
        "description": "Service is not running; no requests or jobs are processed.",
        "terminal": false
      },
      {
        "name": "STARTING",
        "description": "Configuration is being loaded, dependencies are being connected, health checks run.",
        "terminal": false
      },
      {
        "name": "RUNNING",
        "description": "Service accepts requests and processes background jobs.",
        "terminal": false
      },
      {
        "name": "DEGRADED",
        "description": "Service is running but some dependencies are impaired.",
        "terminal": false
      },
      {
        "name": "STOPPING",
        "description": "Service is completing in-flight work and preparing to shut down.",
        "terminal": false
      }
    ],
    "transitions": [
      {
        "from": "STOPPED",
        "to": "STARTING",
        "trigger": "start_command",
        "responsible_module": "ServiceHost"
      },
      {
        "from": "STARTING",
        "to": "RUNNING",
        "trigger": "startup_checks_passed",
        "responsible_module": "ServiceHost"
      },
      {
        "from": "RUNNING",
        "to": "DEGRADED",
        "trigger": "dependency_health_fails",
        "responsible_module": "HealthMonitor"
      },
      {
        "from": "RUNNING",
        "to": "STOPPING",
        "trigger": "stop_command",
        "responsible_module": "ServiceHost"
      },
      {
        "from": "STOPPING",
        "to": "STOPPED",
        "trigger": "all_work_completed",
        "responsible_module": "ServiceHost"
      }
    ],
    "state_owner": "ServiceHost"
  },
  "modules": [
    {
      "name": "ServiceHost",
      "layer": "infrastructure",
      "responsibilities": [
        "Own the service lifecycle state machine.",
        "Start and stop HTTP servers, worker hosts, and shared resources.",
        "Coordinate configuration loading and dependency wiring."
      ],
      "non_responsibilities": [
        "Business rule implementation.",
        "Low-level database access."
      ],
      "dependencies": [
        "ConfigurationProvider",
        "HttpApiHost",
        "WorkerHost",
        "HealthMonitor",
        "Logger",
        "MetricsCollector"
      ]
    },
    {
      "name": "HttpApiHost",
      "layer": "interface",
      "responsibilities": [
        "Expose HTTP endpoints for synchronous request/response operations.",
        "Route incoming requests to application services or command handlers.",
        "Handle basic concerns like authentication/authorization if configured."
      ],
      "non_responsibilities": [
        "Implementing business logic itself.",
        "Persisting data directly; must call repositories or application services."
      ],
      "dependencies": [
        "ApplicationServices",
        "Logger"
      ]
    },
    {
      "name": "WorkerHost",
      "layer": "infrastructure",
      "responsibilities": [
        "Poll queues or schedules and dispatch background jobs.",
        "Control concurrency for job execution.",
        "Report job results and failures."
      ],
      "non_responsibilities": [
        "Defining specific job semantics (handled by job handlers)."
      ],
      "dependencies": [
        "JobScheduler",
        "JobHandlers",
        "Logger",
        "MetricsCollector"
      ]
    },
    {
      "name": "ApplicationServices",
      "layer": "domain",
      "responsibilities": [
        "Implement use cases and orchestrate domain operations.",
        "Apply domain rules and invariants."
      ],
      "non_responsibilities": [
        "Direct HTTP or transport concerns.",
        "Direct SQL or driver-level persistence."
      ],
      "dependencies": [
        "DomainModel",
        "Repositories",
        "ExternalServiceClients"
      ]
    }
  ],
  "classes": [
    {
      "name": "ServiceHost",
      "module": "ServiceHost",
      "kind": "class",
      "responsibilities": [
        "Control the lifecycle of the service process.",
        "Coordinate startup, health checks, and graceful shutdown."
      ],
      "attributes": [
        { "name": "config", "type": "ServiceConfig", "description": "Immutable configuration for this service instance." },
        { "name": "state", "type": "ServiceState", "description": "Current lifecycle state of the service." },
        { "name": "http_host", "type": "HttpApiHost", "description": "HTTP interface host." },
        { "name": "worker_host", "type": "WorkerHost", "description": "Background worker host." }
      ],
      "methods": [
        {
          "name": "start",
          "purpose": "Initialize dependencies, start HTTP/worker hosts, and transition to RUNNING when healthy.",
          "parameters": [],
          "returns": { "type": "void" },
          "side_effects": [
            "Changes service state.",
            "Starts HTTP listener and worker polling."
          ],
          "errors": [
            "InitializationError if mandatory dependencies cannot be initialized."
          ]
        },
        {
          "name": "stop",
          "purpose": "Trigger graceful shutdown of HTTP and worker hosts, and transition to STOPPED.",
          "parameters": [],
          "returns": { "type": "void" },
          "side_effects": [
            "Stops accepting new requests.",
            "Waits for in-flight work to complete or times out."
          ],
          "errors": [
            "ShutdownError if resources cannot be shut down cleanly."
          ]
        }
      ]
    },
    {
      "name": "HttpApiHost",
      "module": "HttpApiHost",
      "kind": "class",
      "responsibilities": [
        "Bind and listen on configured HTTP ports.",
        "Translate HTTP requests into application-level commands or queries."
      ],
      "attributes": [
        { "name": "routes", "type": "list<RouteDefinition>", "description": "Registered API routes and handlers." },
        { "name": "server_config", "type": "ServerConfig", "description": "Host and port configuration." }
      ],
      "methods": [
        {
          "name": "start",
          "purpose": "Begin listening for incoming HTTP requests.",
          "parameters": [],
          "returns": { "type": "void" },
          "side_effects": [
            "Opens listening sockets.",
            "Starts request handling loop."
          ],
          "errors": [
            "NetworkError if ports are unavailable."
          ]
        }
      ]
    }
  ],
  "data_structures": [
    {
      "name": "ServiceConfig",
      "kind": "data_type",
      "description": "Top-level configuration for the service process.",
      "fields": [
        { "name": "service_name", "type": "string" },
        { "name": "environment", "type": "string" },
        { "name": "http_port", "type": "int" },
        { "name": "worker_concurrency", "type": "int" }
      ]
    },
    {
      "name": "ServiceState",
      "kind": "enum",
      "description": "Lifecycle states for the service.",
      "values": ["STOPPED", "STARTING", "RUNNING", "DEGRADED", "STOPPING"]
    },
    {
      "name": "RouteDefinition",
      "kind": "data_type",
      "description": "Describes a single HTTP route and its handler.",
      "fields": [
        { "name": "method", "type": "string" },
        { "name": "path", "type": "string" },
        { "name": "handler_name", "type": "string" }
      ]
    }
  ],
  "config": {
    "object_name": "ServiceConfig",
    "fields": [
      {
        "name": "service_name",
        "type": "string",
        "description": "Logical name of the service.",
        "constraints": "non_empty",
        "default": "example-service",
        "consumed_by": ["ServiceHost", "Logger"]
      },
      {
        "name": "environment",
        "type": "string",
        "description": "Deployment environment label.",
        "constraints": "e.g., dev, test, prod",
        "default": "dev",
        "consumed_by": ["ServiceHost", "MetricsCollector"]
      },
      {
        "name": "http_port",
        "type": "int",
        "description": "Port number for HTTP listener.",
        "constraints": "1..65535",
        "default": 8080,
        "consumed_by": ["HttpApiHost"]
      },
      {
        "name": "worker_concurrency",
        "type": "int",
        "description": "Maximum number of concurrent background jobs.",
        "constraints": ">= 1",
        "default": 4,
        "consumed_by": ["WorkerHost"]
      }
    ]
  },
  "randomness": {
    "uses_randomness": true,
    "rng_owner_module": "ApplicationServices",
    "rng_class": "RandomProvider",
    "seeding_policy": "Seeds may be configured explicitly in ServiceConfig or derived from system time. Deterministic behavior is expected when an explicit seed is provided.",
    "consumers": [
      "IdGenerators",
      "SamplingOrBackoffLogic"
    ]
  },
  "error_handling": {
    "global_policy": "Configuration and initialization errors abort startup; runtime errors are logged and either surfaced to clients or handled with retries based on module policy.",
    "error_types": [
      "InitializationError",
      "ConfigurationError",
      "NetworkError",
      "PersistenceError",
      "JobExecutionError"
    ],
    "recoverable_errors": [
      "Transient network failures for outgoing calls.",
      "Database timeouts when retry policy is enabled."
    ],
    "fatal_errors": [
      "Invalid critical configuration at startup.",
      "Persistent failure of core dependencies that prevents safe operation."
    ]
  },
  "logging": {
    "levels": ["DEBUG", "INFO", "WARN", "ERROR"],
    "key_events_logged": [
      "Service start and stop.",
      "Health check failures and recoveries.",
      "Unexpected exceptions in request or job handlers."
    ],
    "metrics": [
      "request_latency_ms",
      "request_rate",
      "job_throughput",
      "error_rate"
    ]
  },
  "performance": {
    "target_latency_ms_p95": 200,
    "target_throughput_rps": 100,
    "critical_paths": [
      "Database interactions in request handlers.",
      "External API calls.",
      "Job execution under peak load."
    ]
  },
  "extension_points": [
    {
      "name": "DataStoreAdapter",
      "description": "Pluggable persistence implementation (SQL, NoSQL, in-memory, etc.).",
      "registration": "Provided to ApplicationServices or Repositories during startup."
    },
    {
      "name": "MessageBusAdapter",
      "description": "Pluggable message queue or event bus integration.",
      "registration": "Injected into WorkerHost and ApplicationServices."
    }
  ],
  "testing": {
    "strategy": "Unit tests for domain and application services, integration tests for HTTP endpoints and background jobs using fake adapters.",
    "unit_test_targets": [
      "ApplicationServices",
      "Repositories",
      "JobHandlers"
    ],
    "integration_test_scenarios": [
      "HTTP request flows using in-memory HTTP host and fake datastore.",
      "Background job execution with in-memory queues.",
      "Error and retry behavior for external dependencies."
    ],
    "test_doubles": [
      "FakeDataStore",
      "FakeMessageBus",
      "FakeExternalServiceClient"
    ]
  }
}
