{
  "attribution_rules": {
    "source_of_truth": [
      "The relationship.json file is the sole source of architectural truth.",
      "The attribution agent MUST NOT create, remove, or rename classes, change file_path, change role, or alter depends_on declared in relationship.json.",
      "Any desired architectural change (new dependency, new class, new module path) MUST be done by updating relationship.json first, not by the attribution agent."
    ],
    "class_scope": [
      "For each class entry in relationship.json, generate exactly one blueprint entry in blueprint.json.",
      "Blueprint entries MUST preserve: id, file_path, class_name, role from the relationship.",
      "Blueprints MAY add imports, fields, constructors, methods, and notes, but MUST NOT contradict or extend the architecture defined in relationship.json."
    ],
    "imports": [
      "Project imports MUST be derived solely from the class's depends_on list in relationship.json.",
      "For each dependency D in depends_on, the attribution agent SHOULD generate a corresponding project import, e.g. from <D module> import <D class_name>.",
      "The attribution agent MUST NOT import any other project class (e.g., other domain entities, controllers, services) that is not listed in depends_on, even for type hints.",
      "The attribution agent MUST NOT generate self-imports. For example, for class app.main.App, it MUST NOT generate `from app.main import App`.",
      "Standard library and typing imports (e.g., logging, typing.Dict, typing.List, typing.Optional) are allowed and do not count as architectural dependencies.",
      "If richer typing would require importing a project class that is not in depends_on, the attribution agent MUST avoid that import and instead use primitives (str, float, bool, dict) or typing aliases (Dict, List, Optional, Any)."
    ],
    "fields": [
      "For each dependency D in depends_on, blueprint SHOULD introduce exactly one field with origin = 'dependency'.",
      "Field names MUST be snake_case with a leading underscore when appropriate (e.g., _logger, _controller, _service, _repository, _storage, _entity_model).",
      "Field types MUST correspond to the dependent class_name (e.g., LoggerAdapter, SomeController, SomeService, SomeRepository, JsonStorageAdapter, DomainEntity).",
      "Blueprints MUST NOT introduce additional dependency fields for project classes that are not present in depends_on.",
      "Non-dependency state fields (origin = 'state') are allowed only for domain models and other clearly local state; they MUST NOT represent new architectural dependencies."
    ],
    "constructors": [
      "Constructor parameters SHOULD mirror dependency fields 1:1 (same names and types, same order where practical).",
      "Constructor body_plan MUST be limited to assigning parameters to fields and performing trivial, non-I/O initialization.",
      "Constructors MUST NOT perform file I/O, network calls, or domain-level business logic.",
      "If a class has no dependencies in depends_on, constructor parameters MAY be empty or limited to configuration primitives."
    ],
    "methods": [
      "Methods MUST be derived from interactions in relationship.json and from the class role (e.g., orchestration, controller, domain_service, repository, storage_adapter, logging_adapter, domain_model).",
      "The attribution agent MUST NOT introduce new collaborators or cross-component calls beyond those implied by depends_on and interactions.",
      "Where the relationship describes a method-like interaction (e.g., list/create/update/delete or a clearly named operation), blueprint SHOULD create a method stub with parameters and a body_plan expressed as concrete, deterministic steps.",
      "Business logic, persistence logic, and external side-effects MUST be expressed as concrete, deterministic steps sufficient to implement the method without guessing.",
      "If the relationship.json is ambiguous, the attribution agent MUST resolve the ambiguity by selecting the most conservative deterministic behavior consistent with the role and interactions, and MUST document the decision in the notes field."
    ],
    "domain_model_rules": [
      "Classes with role = 'domain_model' MUST remain passive.",
      "Domain models MUST NOT receive dependency fields with origin = 'dependency'.",
      "Domain models MUST NOT import controllers, services, repositories, storage adapters, or loggers.",
      "Allowed methods on domain models are limited to: constructor, simple validation helpers, and pure serialization helpers (e.g., to_dict, from_dict).",
      "Domain models MUST NOT perform I/O, logging, or call other architectural components.",
      "Any complex validation or business invariants belong in domain_service classes, not in domain_model."
    ],
    "logging_adapter_rules": {
      "allowed_logging_methods": [
        "debug",
        "info",
        "warning",
        "error"
      ],
      "non_logging_classes_forbidden_stdlib_logging": true,
      "rules": [
        "Only classes with role='logging_adapter' may import the stdlib 'logging' module.",
        "Non-logging classes MUST NOT import 'logging' directly if they already depend on a logging adapter (e.g., AppLogger).",
        "All other classes must use only their injected logging adapter for logging behavior."
      ],
      "notes": [
        "This ensures that logging concerns remain isolated to the logging adapter.",
        "Prevents accidental architectural leakage where infrastructure or storage layers import stdlib logging."
      ]
    },
    "type_rules": [
      "Project types (e.g., DomainEntity, SomeService, SomeRepository, JsonStorageAdapter, LoggerAdapter) MAY be used as type annotations ONLY when the relationship.depends_on includes the corresponding class.",
      "If a method conceptually returns or accepts a project type that is not declared in depends_on, the attribution agent MUST instead use a more generic type (e.g., dict, List[dict]) until the relationship is updated.",
      "Primitive and typing-based types (str, int, float, bool, Dict, List, Optional, Any) are always allowed and do not require relationship-level dependencies.",
      "When in doubt, the attribution agent MUST prefer generic Dict/List types rather than introducing new project-level dependencies."
    ],
    "consistency_rules": [
      "Every project import generated in the blueprint MUST correspond to a class present in the relationship.json and listed in the current class's depends_on.",
      "Every dependency in depends_on SHOULD normally result in a corresponding field and project import, unless the relationship or role clearly describes an unused or purely conceptual dependency.",
      "Blueprints MUST NOT change or reinterpret dependency direction; they simply express the call relationships already encoded in the relationship interactions.",
      "If the attribution agent detects inconsistencies in relationship.json (e.g., ambiguous or conflicting interactions), it MUST NOT 'fix' them in the blueprint. Instead, it MUST describe the inconsistency in the notes field for that class."
    ],
    "example_usage_rules": [
      "Any blueprint examples included in context are FORMAT-ONLY and MUST NOT be treated as architectural templates.",
      "The attribution agent MUST derive architecture and dependencies solely from relationship.json, not from example files.",
      "Examples may illustrate the shape of imports, fields, constructors, methods, and notes, but MUST NOT influence which classes depend on which other classes."
    ],
    "typing_import_consistency": {
      "rules": [
        "For every typing symbol used in any method or constructor signature (e.g., List, Dict, Optional, Any), the attribution agent MUST ensure that the corresponding name is included in the typing import list.",
        "If the agent prefers to avoid additional typing imports, it MAY instead use built-in generics introduced in Python 3.9+ (e.g., list[str], dict[str, Any]) — but MUST use one style consistently within the class.",
        "The agent MUST NOT reference a typing construct in a type annotation unless one of the following is true: (a) the name is included in the typing import list, or (b) a built-in generic form is used that requires no import.",
        "Missing typing imports MUST be treated as a correctness error in the blueprint and MUST NOT be silently omitted."
      ]
    },
    "storage_path_ownership": {
      "rules": [
        "If relationship.json defines interactions requiring a 'path' parameter (e.g., storage.read(path), storage.write(path, data)), the attribution agent MUST NOT invent new dependencies or configuration objects to supply the path.",
        "The attribution agent MUST choose one of two explicit patterns, depending on what relationship.json defines:",
        "PATTERN A — Method-level path parameter: If the relationship implies repository → storage calls include a path argument, the repository methods MUST explicitly include 'path' in their signatures.",
        "PATTERN B — Repository-owned path: If the relationship implies the repository manages storage configuration, the repository MUST have a state field such as '_path: str', provided via constructor or default.",
        "If the relationship.json does not clearly specify which component owns the storage path, the attribution agent MUST NOT improvise a design choice and MUST instead insert a note indicating that path ownership is undefined and must be resolved in relationship.json.",
        "Under no circumstances may the attribution agent introduce new dependencies (e.g., Config, Settings), new fields, or new constructor parameters that are not present in relationship.json to solve the path ownership ambiguity."
      ]
    },
    "command_contract_consumption_rules": [
  "If relationship.json includes a command contract for an interaction (e.g., App -> Controller), the attribution agent MUST use that contract to define controller method signatures, parameter types, validation steps, and allowed action dispatch mapping.",
  "The attribution agent MUST NOT create or modify command contracts. Command contracts are authored only in relationship.json.",
  "If a controller/handler method receives a command/request object but relationship.json does not provide a matching command contract, the attribution agent MUST fail generation for that class by adding a notes entry indicating 'MISSING_COMMAND_CONTRACT' and leaving the method undefined rather than emitting placeholders or partial schemas."
],

  "error_severity_rules": {
    "levels": {
      "minor": "Local, correctable issues. Structure is valid. Intent is understood.",
      "major": "Multiple violations or partial misunderstanding. Structure exists but is unreliable.",
      "fatal": "Invalid JSON, schema totally broken, or intent misunderstood."
    },
    "routing": {
      "minor": "refiner",
      "major": "refiner",
      "fatal": "remake"
    }
  }
  }
}
