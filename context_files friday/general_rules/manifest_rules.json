{
  "manifest_rules": {
    "inputs": [
      "relationship.json — canonical architecture (classes, file paths, roles, depends_on, interactions).",
      "blueprint.json — attribution details (imports, fields, constructors, methods, notes)."
    ],

    "output_contract": [
      "Produce exactly one manifest.json object.",
      "The manifest describes modules, classes, dependencies, constructors, methods, config objects, and (optionally) initialization wiring in a form that downstream code generators can use without guessing.",
      "The manifest MUST NOT contradict relationship.json; it may only refine or normalize what is already declared."
    ],

    "source_of_truth": [
      "relationship.json is the sole source of architectural truth (classes, file_path, roles, dependency directions).",
      "blueprint.json is the sole source of detailed class structure (imports, fields, constructors, methods) but MUST NOT introduce new architectural elements that are absent from relationship.json.",
      "If blueprint.json disagrees with relationship.json (e.g., new dependency, changed file_path), the manifest agent MUST follow relationship.json and treat the mismatch as an error to be reported in a notes/diagnostics section (if present in the schema)."
    ],  
    "class_and_module_mapping": [
      "For each class in relationship.json, manifest MUST contain exactly one class entry.",
      "Manifest MUST preserve: id, file_path, class_name, role as defined in relationship.json.",
      "The manifest layer/module naming MUST be derived from file_path and/or role; the manifest agent MUST NOT invent new package structures or move classes between modules.",
      "Example: relationship.file_path='expense_tracker/service.py' implies manifest module='expense_tracker.service' and file='expense_tracker/service.py' (or equivalent normalized form)."
    ],

    "dependency_mapping": [
      "For each class, manifest dependencies MUST be derived solely from relationship.depends_on.",
      "The manifest MAY use blueprint.imports and blueprint.fields to confirm or refine dependency information, but it MUST NOT add dependencies that are not present in relationship.depends_on.",
      "Every depends_on entry MUST normally appear as a dependency in the manifest (unless explicitly marked conceptual or unused in relationship).",
      "Any project dependency present in blueprint.imports but missing from relationship.depends_on MUST NOT be added to the manifest; it MUST be treated as a violation and optionally surfaced in diagnostics/notes."
    ],

    "constructor_mapping": [
      "Constructor signatures in the manifest MUST be derived from blueprint.constructor where present.",
      "Constructor parameters MUST be consistent with dependency fields derived from relationship.depends_on (e.g., logger: AppLogger, service: ExpenseService).",
      "The manifest MUST NOT introduce new constructor parameters for project classes that are not present in relationship.depends_on.",
      "If blueprint lacks constructor information for a class that has dependencies, the manifest agent MUST synthesize a minimal constructor with one parameter per dependency (using relationship.depends_on) and mark it as TODO/origin='inferred'.",
      "Trivial or primitive parameters (e.g., config primitives) MAY be included if they appear in blueprint or in a separate config object definition; the manifest MUST NOT invent them from nothing."
    ],

    "method_mapping": [
      "Manifest method entries (if the schema includes them) MUST be derived from blueprint.methods.",
      "Methods MUST NOT introduce new collaborators beyond those implied by relationship.depends_on.",
      "If relationship.interactions describe a method-like operation that blueprint did not include, the manifest agent MAY add a method stub with TODO steps, but MUST NOT add new dependencies or side-effects.",
      "Method names, parameters, and return types MUST be copied from blueprint; where blueprint uses TODO or generic types, manifest MUST preserve that uncertainty rather than guessing."
    ],

    "config_and_state_rules": [
      "Domain configuration objects (e.g., ServiceConfig) MUST be taken from either data_structures in the story/manifest context or from explicit config/domain_model entries in relationship/blueprint (if available).",
      "The manifest agent MUST NOT invent new global Config, Settings, or Environment classes that are not present in relationship.json or in the upstream story context.",
      "State enums (e.g., ServiceState) MAY be represented as manifest-level enums if they are present in relationship or upstream story; otherwise they must not be invented.",
      "The manifest MUST respect path-ownership rules established by attribution: if blueprint shows path as a method-level parameter and no _path field, the manifest MUST NOT reintroduce _path state."
    ],

    "initialization_and_wiring_rules": [
      "If the upstream story or context provides an explicit initialization_graph, the manifest agent MUST copy and normalize that graph into manifest.json without changing dependency order or composition_root.",
      "If NO explicit initialization_graph is provided, the manifest agent MAY derive a simple initialization order for convenience by topologically sorting classes based on constructor dependencies (component dependencies only). This MUST be marked as derived/inferred in the manifest.",
      "The manifest agent MUST NOT invent a new composition_root (e.g., ServiceHost, App) if relationship.json does not contain a clear orchestration class (role='orchestration' or equivalent). In such cases, the manifest MUST either omit the initialization_graph or include a TODO note indicating that the composition root is undefined.",
      "Under no circumstances may the manifest agent change dependency direction or add extra wiring to satisfy inferred initialization; if the dependency graph is cyclic or ambiguous, the manifest MUST report this as a diagnostics issue instead of 'fixing' it."
    ],
    
  "module_namespace_consistency_rule": {
    "severity": "error",
    "rule": "For each module, the declared module namespace MUST align with its file_path. If file_path contains subdirectories, the module namespace MUST reflect the full Python import path. Code generators MUST NOT infer or correct mismatches."
  },
    "logging_and_infrastructure_rules": [
      "If logging_adapter_rules state that only logging_adapter classes may import stdlib 'logging', the manifest MUST reflect this by treating logging adapters as the sole owner of logging configuration/responsibility.",
      "Non-logging classes MUST appear in the manifest as depending on a logging adapter (e.g., AppLogger) rather than on stdlib logging directly, in alignment with relationship and blueprint.",
      "Infrastructure components (storage adapters, repositories, worker hosts, API hosts, etc.) MUST NOT be assigned new responsibilities (e.g., config loading, random seeding, health checking) unless those responsibilities are explicitly present in relationship and/or the upstream story."
    ],

    "path_ownership_rules": [
      "If blueprint shows method-level path parameters (e.g., read(path), write(path, data)), the manifest MUST model that as method-level configuration and MUST NOT introduce _path fields or new Config classes to hold paths.",
      "If relationship.json explicitly defines a repository-owned path field (e.g., a state field '_path: str' as part of the architecture), the manifest MAY represent that as constructor-injected configuration, but MUST NOT add it where the relationship does not define it.",
      "In ambiguous cases, the manifest MUST prefer preserving the attribution pattern and MAY include TODO notes instead of making architectural changes."
    ],

    "type_and_import_consistency": [
      "Project type references in the manifest (e.g., class dependencies) MUST correspond to classes present in relationship.json.",
      "Types used only for documentation (e.g., return_type: TODO, dict, list[dict]) MAY be copied directly from blueprint and do not require additional relationship dependencies.",
      "The manifest agent MUST NOT introduce new project-level types (classes, enums, interfaces) not present in relationship.json or in the upstream story context.",
      "If blueprint includes richer typing that would require importing project classes not in depends_on, the manifest MUST fall back to generic types (dict, list, TODO) in order to remain consistent with relationship."
    ],

    "consistency_and_error_reporting": [
      "The manifest MUST be internally consistent: class ids, file_paths, and roles must match between manifest and relationship.",
      "Any inconsistency detected between relationship.json and blueprint.json (extra imports, missing dependencies, conflicting constructor signatures) MUST NOT be silently corrected; the manifest agent must either (a) follow relationship.json and drop the conflicting blueprint detail, and/or (b) record a diagnostics entry or TODO note.",
      "Manifest MUST NOT merge or split classes relative to relationship.json (e.g., MUST NOT collapse multiple repositories into one or split a single service into multiple entries).",
      "Example or demo manifests present in context are FORMAT-ONLY and MUST NOT be treated as authoritative architecture; the manifest agent MUST derive all structural information from relationship + blueprint + explicit story metadata (if available)."
    ],
    
  "local_persistence_rules": {
    "summary": "Generic, deterministic rules for applications that persist state locally via a storage adapter.",
    "rules": [
      {
        "id": "persistence.bootstrap_safe_reads",
        "severity": "error",
        "rule": "Read operations on persistent storage MUST be bootstrap-safe: if the underlying storage resource does not exist, the read MUST return the appropriate empty default for the expected data shape and MUST NOT raise an unhandled exception."
      },
      {
        "id": "persistence.explicit_schema_boundary",
        "severity": "error",
        "rule": "Each persistence boundary (repository or equivalent) MUST declare the expected root data shape and required fields for persisted records. Code MUST NOT assume the presence of fields that are not explicitly declared."
      },
      {
        "id": "persistence.identity_policy_required",
        "severity": "error",
        "rule": "If the application supports operations that reference persisted records by identifier, an explicit identity policy MUST exist defining: (a) which layer creates identifiers, (b) identifier type/format, and (c) immutability. No layer may assume identifiers exist unless this policy is declared."
      },
      {
        "id": "persistence.identity_stability",
        "severity": "error",
        "rule": "Once assigned, a record identifier MUST remain stable for the lifetime of that record and MUST NOT be regenerated or mutated during updates."
      },
      {
        "id": "persistence.atomic_mutations",
        "severity": "error",
        "rule": "Persisted state mutations MUST be atomic at the storage boundary. Partial writes or partially applied mutations MUST NOT be observable after failures."
      },
      {
        "id": "persistence.error_normalization",
        "severity": "error",
        "rule": "All storage-layer failures (missing resources, permission errors, corrupted state, schema violations) MUST be normalized into a deterministic application-level error response. The application MUST NOT terminate unexpectedly due to storage errors."
      },
      {
        "id": "persistence.no_implicit_contracts",
        "severity": "error",
        "rule": "No component may rely on implicit persistence contracts. Any field read or written by a component MUST be part of the declared persistence schema or identity policy."
      },
      {
        "id": "persistence.deterministic_observability",
        "severity": "warning",
        "rule": "Observable outputs derived from persisted state (e.g., list operations) SHOULD be deterministic in ordering and content to ensure reproducible behavior."
      }
    ]
  }
,
    
  "error_severity_rules": {
    "levels": {
      "minor": "Local, correctable issues. Structure is valid. Intent is understood.",
      "major": "Multiple violations or partial misunderstanding. Structure exists but is unreliable.",
      "fatal": "Invalid JSON, schema totally broken, or intent misunderstood."
    },
    "routing": {
      "minor": "refiner",
      "major": "refiner",
      "fatal": "remake"
    }
  }

  }
}
